PRO qpo_lc,path=path,obj_time=obj_time,bt=bt, $
           seed=seed,nsimul=nsimul, $
           write=write,files=files, $
           chatty=chatty, $
           time=time,rate=ra,poisson=poisson, $
           rednoise=rednoise,mean=mea,sigma=sigma,beta=beta, $
           whitenoise=whitenoise, $
           const=const, $
           model=model,params=params,$
           nogap=nogap,factor=factor, $
           _extra=extra
;+
; NAME:
;         qpo_lc
;
;
; PURPOSE:
;         Simulate lightcurves for computation of period significance
;
;
; CATEGORY:
;         time series analysis
;
;
; CALLING SEQUENCE:
;
;
;
; INPUTS:
;          obj_time: times when the data in the original light curve
;                    were measured
;          nsimul: number of simulations
;
;
; OPTIONAL INPUTS:
;          bt      : bintime of the lightcurve in seconds, if not
;                    given, obj_time[1]-obj_time[0] is used
;          model: set to the name of a function which returns the desired
;                    PSD shape. The function must obey the calling conventions
;                    of mpfitfun, the parameter values of the function are
;                    set by the keyword params (see description of IDL
;                    routine timmerlc, see also const, rednoise,
;                    whitenoise, and poisson keywords)
;          sigma:    stddev of the lc
;          mean:     mean of the lc
;          seed: initialization information for the random number generator
;
;
; KEYWORD PARAMETERS:
;    const: if set, simulate constant lightcurve with countrate given
;           by the mean count rate (value of the keyword mean)
;    rednoise: if set, simulate f^(-beta) noise. Required keywords
;           are: beta: slope, mean: mean countrate, sigma: variance
;    whitenoise: if set, simulate white noise. Required keywords
;           are: mean and sigma
;    poisson: if set, instrumental noise is added to the simulated
;           lightcurve using the deadtime_simul procedure
;           (deadtime_simul is called with the extra keyword, i.e., it
;           is also possible to simulate deadtime this way)
;    model : if model is given, then the PSD of the simulated
;           lightcurves is computed from an arbitrary shape, which is
;           defined by the function given in this string parameter (see
;           documentation for timmerlc);  the parameters defining the
;           shape of the PSD are taken from the keyword params
;    chatty: if set, be chatty
;     write: if set: write lightcurves instead of returning them in
;            time and rate.
;            Enables the following keywords:
;              path: directory where the data is to be written to
;              files: string-array containing the file names of the
;                     files generated in this simulation.
;      nogap: if set, simulate lightcurve for duration of whole obj_time,
;            but ignore gaps in input lightcurve
;      factor: due to the way the lightcurves are generated, they are
;            affected by red noise leakage if the duration of the
;            simulated lightcurves is only as long as the duration of
;            the observation. factor allows to increase the time span
;            for which the lightcurves are generated by a factor of
;            2^factor. Default: 3
;
; OUTPUTS:
;      The following two outputs are only present if the write-keyword
;      has not been set:
;         time: arrays containing the simulation times (these can be
;               different from obj_time due to roundoff OR if the
;               sampling of obj_time is not uniform).
;         rate: 2D array containing the simulated lightcurves.
;
;
; OPTIONAL OUTPUTS:
;
;
;
; SIDE EFFECTS:
;       If the write-keyword is set, then the lightcurves are written
;       to files.
;
;
; RESTRICTIONS:
;       many. and the documentation should be much better than it
;       currently is.
;
;
; PROCEDURE:
;       to be written
;
;
; EXAMPLE:
;       to be written
;
;
; MODIFICATION HISTORY:
;        Version 1.0, 2002/01/10, Sara Benlloch, IAAT
;        Many modifications since then and 2002 September
;
; DO NOT EDIT THE FOLLOWING LINES. THEY ARE AUTOMATICALLY GENERATED
;
; $Log: qpo_lc.pro,v $
; Revision 1.1  2002/09/12 09:58:22  wilms
; initial release into aitlib
;
;
;-



    ;; switch of chattiness if needed
    IF (NOT keyword_set(chatty)) THEN chatty=0

    IF (n_elements(obj_time) EQ 0) THEN BEGIN 
        message,'Must give observation times (obj_time-keyword)'
    ENDIF 

    IF (n_elements(nsimul) EQ 0) THEN BEGIN 
        message,'Must give number of simulations (nsimul-keyword)'
    ENDIF 

    ;; make lightcurves 2^factor longer than original lightcurve 
    ;; to reduce effect of red noise leakage
    IF (n_elements(factor) EQ 0) THEN factor=3

  
    ;; Sanity check for the model selection
    nummod=(n_elements(model) NE 0)+keyword_set(const)+ $
      keyword_set(rednoise)+keyword_set(whitenoise)
    IF (nummod GT 1) THEN BEGIN 
        message,'Only one of the keywords model, const, ',/informational
        message,'rednoise, and whitenoise can be set'
    ENDIF 
  
    IF (keyword_set(write) AND n_elements(path) EQ 0) THEN BEGIN 
        message,'path-keyword is not set.',/informational
        message,'Writing data to current working directory',/informational
        path='.'
    ENDIF 

    IF (n_elements(bt) EQ 0) THEN BEGIN 
        bt=obj_time[1]-obj_time[0]
    ENDIF 

    nn=n_elements(obj_time)
    length=obj_time[nn-1]-obj_time[0]
    dur= length/bt

    ;; round up to power of two to speed up simulations
    nt=long ( 2.^(fix(alog(dur)/alog(2.))+1+factor) )

    IF (keyword_set(write)) THEN BEGIN 
        openw,unit1,path+'/history.txt',/get_lun
        printf,unit1,'Original length of the lc',length
        printf,unit1,'Desired length of the lc',nt*bt
        printf,unit1,'Bintime',bt
        printf,unit1,'Stddev',sigma
        printf,unit1,'Mean',mea
        printf,unit1,'Number of Simulations',nsimul
        IF (keyword_set(whitenoise)) THEN BEGIN 
            printf,unit1,'White noise simulation'
        ENDIF 
        IF (keyword_set(rednoise)) THEN BEGIN 
            printf,unit1,'Red noise simulation'
            printf,unit1,'  Beta:',beta
        ENDIF 
        IF (keyword_set(const)) THEN BEGIN 
            printf,unit1,'Simulation of constant lightcurve'
        ENDIF 
        IF (n_elements(model) NE 0) THEN BEGIN 
            printf,unit1,'Simulation using model function '+model
            printf,unit1,'   Parameters: '+params
        ENDIF 
        IF (keyword_set(poisson)) THEN BEGIN 
            printf,unit1,'Poisson noise added to the simulation'
        ENDIF 
  
        printf,unit1,'seed for the random generator', seed
        free_lun,unit1
      
        files=strarr(nsimul)

    ENDIF ELSE BEGIN 
        ra=fltarr(nsimul,nt)
    ENDELSE 

    ;; Determine gaps of the lightcurve
    IF (keyword_set(nogap)) THEN BEGIN 
        gap=[-1]
    ENDIF ELSE BEGIN 
        timegap,obj_time,bt=bt,gap,block,gapdura,tol=1E-4,chatty=chatty
    ENDELSE 


    FOR i=0L,nsimul-1 DO BEGIN 
        ;;
        ;; Print out progress message if desired
        ;;
        qpo_progress,i,nsimul,t0,chatty=chatty,name='qpo_lc'
        ;;
        ;; simulate light curve
        ;;
        IF (keyword_set(const)) THEN BEGIN 
            ;; Simulate constant lightcurve (e.g., for window)
            time = dindgen(nt)*bt + bt
            rate = replicate(mea,nt)
        ENDIF 
        IF (keyword_set(rednoise)) THEN BEGIN 
            ;; red noise simulation
            rndpwrlc,time,rate,nt=nt,dt=bt,beta=beta, $
              sigma=sigma,mean=mea,seed=seed
        ENDIF 
        IF (keyword_set(whitenoise)) THEN BEGIN 
            ;; white noise simulation
            time = dindgen(nt)*bt + bt
            rate = mea + sigma*ran2_normal(seed,dim=nt)
        ENDIF 
        IF (n_elements(model) NE 0) THEN BEGIN 
            ;; simulation using any general shape
            timmerlc,time,rate,nt=nt,dt=bt,mean=mea,sigma=sigma, $
              seed=seed,model=model,params=params,_extra=extra
        ENDIF 

        IF keyword_set(poisson) THEN BEGIN 
            ;; Add instrumental Poisson noise
            deadtime_simul,time,rate,nnrate,seed=seed,_extra=extra
            rate = temporary(nnrate)
        ENDIF 

        ;; In the first round of the simulations, determine the rates to
        ;; be used in the final lightcurve
        ;; (just once to save time when writing data)
        IF (i EQ 0L) THEN BEGIN 
            nti=time+obj_time[0]
            ;; indices of valid times
            IF ( gap[0] NE -1 ) THEN BEGIN 
                ;; lightcurve has gaps
                gap=[-1,gap,n_elements(obj_time)-1]
                timndx=[-1]
                FOR ii=1,n_elements(gap)-1 DO BEGIN 
                    timndx=[timndx, $
                            where(nti GE obj_time[gap[ii-1]+1] AND $
                                  nti LE obj_time[gap[ii]])]
                ENDFOR 
                timndx=timndx[where(timndx NE -1)]
            ENDIF ELSE BEGIN 
                ;; special case of gapless lightcurve
                timndx=where(nti GE obj_time[0] AND $
                             nti LE obj_time[n_elements(obj_time)-1])
            ENDELSE 
            nti=nti[timndx]
        ENDIF 
        ;;
        ;; Save lightcurve
        ;;
        IF (keyword_set(write)) THEN BEGIN 
          
            nra=rate[timndx]

            datafile=path+'/'+string(format='(I5.5)',i)+'.xdr.lc.gz'

            files[i]=datafile

            openw,unit1,datafile,/get_lun,/xdr,/compress
            writeu,unit1,n_elements(nti)
            datat = dblarr(2,n_elements(nti))
            datat[0,*] = nti
            datat[1,*] = nra
            writeu,unit1,datat
            free_lun,unit1
        ENDIF ELSE BEGIN 
            ra[i,*]=rate
        ENDELSE 
    ENDFOR  

    IF (NOT keyword_set(write)) THEN BEGIN 
        ;; Apply gaps
        time=nti
        ra=ra[*,timndx]
    ENDIF 
END 

