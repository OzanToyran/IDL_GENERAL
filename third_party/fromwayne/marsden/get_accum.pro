pro get_accum,fil,a_counts,a_livetime,mode=mode,num=num,$
              noroll=noroll,idfrange=idfrange,raa=raa,deca=deca,$
              manual=manual,freq=freq,fdot=fdot,ffdot=ffdot,$
              t0=t0,nphase=nphase,uldfile=uldfile,tres=tres,$
              edgs=edgs,i1=idfs,i2=idfe,dates=dt,live=idf_lvtme,$
              cl=clstr_pos,iarr=iarr,evts=evts,skipidf=skipidf,$
              alph=alph,bet=bet,widgets=widgets,dlc=dlc_out,$
              b_parms=b_parms,tedgs=tedgs,pzero=pzero
;********************************************************************
; Program reads the accumulated file 'rec____.dat' and 
; accumulates the idl arrays.
; Variables are:
;         fil................File(s) for accumulated data
;    a_counts................Accumulated counts
;  a_livetime................Accumulated livetime
;   idfs,idfe................Start/stop idf #s
;          dt................Array of dates and times
;    pha_edgs................  "    " pha edges
;                            (multiscalar & archive m.)
;     det_str................Which phoswich string (phapsa)
;         chc................Data type for event list
;        mode................Skip widgets, start events accumulation
;         num................# of IDFs to accumulate
;   idf_lvtme................Array of livetimes/idf
;      noroll................Doesn't ''decompress'' archist data
;    idfrange................Only processes data in spec. idf range
;      manual................Array of UTCF corrections (s - optional)
;  raa & deca................Ra & Dec for barycenter correcting (deg.)
;        freq................Frequency (hz) for folding
;        fdot................Frequency derivative (hz^2) for folding
;       ffdot................Frequency 2nd derivative (hz^3)
;          t0................Pulsar timing ephemeris t0
;       pzero................   "      "       "     phi0
;      nphase................Number of phase bins for prs mode
;     uldfile................fasthk file for deadtime corrections
;        tres................time resolution (msclr mode)
;        edgs................energy bin edges (msclr mode)
;        iarr................array of livetimes actually processed
;    alph,bet................deadtime correction factors (XULD, ULD)
;        evts................Accumulates on source event times
;     skipidf................List of IDFs to skip
;       tedgs................Start/Stop time array (msclr mode)
;     widgets................Do widgets if defined
;         dlc................16s lightcurve of Archive Histogram data
;     b_parms................array of timing parameters
; Define the common blocks:
;**********************************************************************
common parms,start,new,clear
common basecom,base,idfold,beep,chc
common wcontrol,whist,wphapsa,wcalhist,wmsclr,warchist,wam,wevt,$
                wfit,wold
common lastpos,last2pos
common bary,ra,dec,asini,porb,t90,ecc,omega_d,p0
common evt_parms,prms,prms_save,burst
common oldulds,xulds_old,ulds_old,idfarr_old,arms_old,trigs_old,$
               vetos_old,alpha,beta
;**********************************************************************
; Display the usage.
;**********************************************************************
if (n_params() eq 0)then begin
   print,'Usage : get_accum,files,counts,livetime,[MODE=see below],' + $
         '[NUM=# of IDFs to accum.],[NOROLL=no archist decomp.],' + $
         '[IDFRANGE=(startidf,endidf)],[RA=for baycentering (deg)],' + $
         '[DEC=for barycentering (deg)],[FREQ=folding frequency (hz)],' + $
         '[FDOT=1st frequency derivative],[ALPH=XULD coeff.],' + $
         '[BET=ULD coeff.],[FFDOT=2nd frequency derivative],' + $
         '[T0=Timing Ephemeris Tzero],[I1=idfstart],[PZER0=phase zero]' + $
         ',[MANUAL=Array of UTCF Corrections (s)],[I2=idfend],' + $
         '[NPHASE=# phase bins],[ULDFILE=fasthk file],' + $
         '[TRES=time binsize (msclr)],[DT=start,stop dates & times],' + $
         '[EDGS=energy edges],[LIVE=idf_lvtme array],' + $
         '[EVTS=(boolean)],[CL=clstr_pos array],[WIDGETS=(boolean)],' + $
         '[IARR=array of IDFs used],[SKIPIDF=IDFs to skip],[DLC=],' + $
         '[B_PARMS=fltarr(5)],[TEDGS=Time array (msclr)]'
   print,''
   print,'For operation without widgets, set mode='
   print,'		"h" for histogram bin output'
   print,'		"p" for phapsa output'
   print,'               "m" for multiscalar output'
   print,'               "prs" for phase-resolved spectroscopy'
   print,''
   print,'Note #1: DT correction needs HK file ("ULDFILE") generated by: '
   print,'fasthk -W ... -n IDF R5 R6 R7 R8 R9 R10 R11 R12 R33 R34 ' 
   print,'R35 R36 R37 R38 R39 R40 R21 R22 R23 R24 ...'
   print,''
   print,'Binary pulsar timing correction array (B_PARMS):'
   print,'    b_parms(0).......asini, projected semi-major axis [lt-secs]'
   print,'    b_parms(1).......porb, orbital period [days]'
   print,'    b_parms(2).......t90, epoch for mean longitude of 90 ' + $
          'degrees [TDB (MJD)]'
   print,'    b_parms(3).......ecc, eccentricity'
   print,'    b_parms(4).......omega_d, longitude of periastron [degrees]'
   return
endif
;**********************************************************************
; Set some control variables
;**********************************************************************
num_files = n_elements(fil)
if (ks(uldfile) ne 0)then begin
   if (n_elements(uldfile) ne num_files)then begin
      uldf = fil
      uldf(*) = uldfile(0)
      uldfile = uldf
   endif
endif else print,'!NO HK FILE FOR DEADTIME CORRECTION - NOT CORRECTING'
if (ks(manual) eq 0)then manual = dblarr(num_files)
start = 1 & clear = 0
count = -1 & idfold = 0
if (ks(idfrange) eq 0)then idfrange = [0l,0l] 
last2pos = ['?','?']
nowait = 0
chc = ''
ulds_s = 0l
iarr = 0l
ulds = 0l
if (n_elements(skipidf) eq 0)then skipidf = 0l
if (ks(mode) eq 0)then modesave = 1 else modesave = 0
if (n_elements(widgets) eq 0)then widgets = 0 else widgets = 1
if (n_elements(edgs) eq 0)then edgs = [1.,256.] $
else edgs = edgs(sort(edgs))
nc = n_elements(edgs) - 1.
;**********************************************************************
; Set the alpha and beta ("gamma") parameters for the different 
; XULD window settings throughout the mission. There are three 
; modes:
;          Mode             XULD Window (us)
;          ----             ----------------
;          "A"..............     300
;          "B"..............  500 or 496 
;          "C"..............     2500
; First define the arrays:
;         didf.............. IDF ranges for mode configurations
;      config1.............. Configuration vs detector (C1)
;      config2.............. Configuration vs detector (C2)
;       coeff1.............. Coefficient Cube (C1)
;       coeff2.............. Coefficient Cube (C2)
;**********************************************************************
didf = lonarr(2,15)
didf(*,0) = [0l,4152872l]
didf(*,1) = [4158032l,4160288l]
didf(*,2) = [4160992l,4271000l]
didf(*,3) = [4272728l,4297824l]
didf(*,4) = [4297824l,4298704l]
didf(*,5) = [4298704l,4308400l]
didf(*,6) = [4309288l,4372928l]
didf(*,7) = [4377160l,4377936l]
didf(*,8) = [4377936l,4416792l]
didf(*,9) = [4416792l,4488472l]
didf(*,10) = [4491344l,6353012l]
didf(*,11) = [6353013l,6355263l]
didf(*,12) = [6355264l,6355438l]
didf(*,13) = [6355439l,6358151l]
didf(*,14) = [6358152l,100000000l]
config1 = intarr(4,15) & config2 = config1
config1(0,2) = 1
config1(*,3:8) = 1
config1(*,9:10) = 2
config1(*,12) = 2
config1(*,14) = 2
config2(0,2) = 1
config2(*,3) = 1
config2(*,5:8) = 1
config2(*,9:10) = 2
config2(*,12) = 2
config2(*,14) = 2
coeff1 = fltarr(2,3,4) & coeff2 = coeff1
coeff1(0,0,*) = [24.58,21.9,18.49,22.9]*1.e-4
coeff1(0,1,*) = [22.2,19.9,16.5,20.9]*1.e-4
coeff1(0,2,*) = [9.98,6.54,3.78,8.74]*1.e-4
coeff1(1,0,*) = [4.35,11.05,24.4,2.35]*1.e-5
coeff1(1,1,*) = [4.35,11.05,24.4,2.35]*1.e-5
coeff1(1,2,*) = [2.1,8.45,21.9,3.5]*1.e-5
coeff2(0,0,*) = [24.52,21.93,22.52,23.4]*1.e-4
coeff2(0,1,*) = [22.5,19.9,20.5,21.4]*1.e-4
coeff2(0,2,*) = [8.32,6.38,0.,8.02]*1.e-4
coeff2(1,0,*) = [5.,11.75,12.3,13.65]*1.e-5
coeff2(1,1,*) = [5.,11.75,12.3,13.65]*1.e-5
coeff2(1,2,*) = [5.15,14.1,0.,10.6]*1.e-5
;**********************************************************************
; Print some notices:
;**********************************************************************
if (ks(raa) ne 0)then begin
   ra = double(raa)
   print,'BARYCENTER CORRECTING AT RA = ',ra 
endif else ra = 0d
if (ks(deca) ne 0)then begin
   dec = double(deca) 
   print,'DEC = ',dec
endif else dec = 0d
;**********************************************************************
; Set binary pulsar timing parameters:
;**********************************************************************
if (n_elements(b_parms) ne 5)then asini = 0. else begin
   print,'SETTING BINARY PULSAR PARAMETERS TO:'
   print,'asini = ',strcompress(b_parms(0))
   print,'porb = ',strcompress(b_parms(1))
   print,'t90 = ',strcompress(b_parms(2))
   print,'ecc = ',strcompress(b_parms(3))
   print,'omega_d = ',strcompress(b_parms(4))
   asini = b_parms(0)
   porb = b_parms(1)
   t90 = b_parms(2)
   ecc = b_parms(3)
   omega_d = b_parms(4)
endelse    
;**********************************************************************
; Set phase zero timing parameter if defined:
;**********************************************************************
if (n_elements(pzero) ne 0)then begin
   p0 = double(pzero)
   print,'SETTING INTIAL PULSAR PHASE TO:',strompress(p0)
endif else p0 = 0d
;**********************************************************************
; Check the mode variables
;**********************************************************************
if (ks(num) eq 0)then num = long(1.e5) else num = num + long(1)
if (ks(mode) ne 0)then begin
   if (mode ne 'h' and mode ne 'p' and mode ne 'm' and mode ne 'prs')$
   then begin
      print,'SORRY, THIS MODE IS NOT AVAILABLE'
      return
   endif
;**********************************************************************
; If prs mode fill the prms array with timing ephemeris and number of 
; phase bins. If no timing parameters are given, load the IOC crab 
; values.
;**********************************************************************
   if (mode eq 'prs')then begin
      prms = dblarr(5)
      if (ks(freq) eq 0)then begin
         print,'USING CRAB TIMING PARAMETERS FROM IOC'
         prms(0) = 29.8928716027569d
         prms(1) = -3.75857d-10
         prms(2) = 1.03d-20
         prms(3) = 60d
      endif else begin
         print,'FREQUENCY = ',freq
         prms(0) = double(freq)
         if (ks(fdot) ne 0)then begin
            print,'FDOT = ',fdot
            prms(1) = fdot
         endif
         if (ks(ffdot) ne 0)then begin
            print,'FFDOT = ',ffdot
            prms(2) = ffdot
         endif
         if (ks(nphase) ne 0)then begin
            print,'NPHASE = ',nphase
            prms(3) = nphase
         endif else begin
            print,'NPHASE = 15'
            prms(3) = 15d
         endelse
         if (ks(t0) ne 0)then begin
            if (ks(ra) ne 0)then begin
               if (n_elements(b_parms) ne 0)then begin
                  print,'ASSUMING T0 IS REFERENCED TO PULSAR ORBIT!'
                  print,'--->SETTING T0 = ',strcompress(t0)
               endif else begin
                  print,'ASSUMING T0 IS IN BARYCENTER DYNAMICAL TIME!'
                  print,'T0 = ',strcompress(t0),' TDB'
               endelse
            endif else print,'ASSUMING T0 = IDF ',strcompress(t0)
            prms(4) = double(t0)
          endif else print,'ASSUMING T0 IS FIRST IDF OF ACCUMULATION!'
      endelse
   endif
;**********************************************************************
; Set the control variable to the proper mode:
;**********************************************************************
   chc = mode 
endif
if (n_elements(prms) eq 0)then prms = 0.
for i = 0,num_files-1 do begin 
;**********************************************************************
; Start accumulation while there is still data in the file:
;**********************************************************************
 if (n_elements(idfrange) gt 2)then begin
    temp = [idfrange(0,i),idfrange(1,i)]
    idfrnge = [min(temp),max(temp)+1]
 endif else idfrnge = [min(idfrange),max(idfrange)+1]
 if (num_files eq 1)then file = fil else file = fil(i)
 print,'ACCUMULATING DATA FROM FILE ',file
 if (total(idfrnge) gt 1l)then print,'USING IDF RANGE',idfrnge(0),$
' TO',idfrnge(1)-1 else print,'STARTING FROM BEGINNING OF FILE!'
 new_file = 1 & acc = '1' 
;**********************************************************************
; Get the XULD and ULD arrays for the given data file:
;**********************************************************************
 if (ks(uldfile) ne 0)then get_ulds,uldfile(i),idfarr,xulds,ulds,arms,$
                                    trigs,vetos
 while (acc eq '1' and count le num - 1l ) do begin
    flag = 1
    new = 1 & idflost = -1
    if (new_file)then begin 
       get_data,file,typ,idf,date,spectra,livetime,lost_events,$
       idf_hdr,err=err
       new_file = 0
    endif else begin
       get_data,file,typ,idf,date,spectra,livetime,lost_events,$
                idf_hdr,flag,err=err
    endelse
    if (typ eq 'ARCh')then begin
       if (n_elements(arch_cor) eq 0)then idfrnge(1) = idfrnge(1)-1l
       arch_cor = 1
    endif       
;**********************************************************************
; Get correct alpha and beta for deadtime correction:
;**********************************************************************
    ifalph = ks(alph) eq 0
    ifbet = ks(bet) eq 0
    in_idf = $
    where(idf ge reform(didf(0,*)) and idf le reform(didf(1,*)))
    za = ks(alpha) eq 0
    zb = ks(beta) eq 0
    str = strcompress(idf_hdr.clstr_id)
    if (str eq 'CEU II')then begin
       config = config2 & coeff = coeff2
       alpha_default = [8.32,6.38,0.,8.02]*1.e-4
       beta_default = [5.15,14.1,0.,10.6]*1.e-5
    endif else begin
       config = config1 & coeff = coeff1
       alpha_default = [9.98,6.54,3.78,8.74]*1.e-4
       beta_default = [2.1,8.45,21.9,3.5]*1.e-5
    endelse
    if (za and ks(uldfile) ne 0 and ifalph)then begin
       if (in_idf(0) ne -1)then begin
          con = reform(config(*,in_idf(0)))
          alpha = fltarr(4)
          for j = 0,3 do alpha(j) = coeff(0,con(j),j)
       endif else begin
          print,'IDF ', idf,$
          ' OUT OF CALIBRATION RANGES - USING DEFAULT ALPHA!'
          alpha = alpha_default
       endelse 
       print,'USING ALPHA =',alpha
    endif
    if (ks(alph) ne 0 and ks(uldfile) ne 0)then begin
       alpha = alph
       print,'USING (MANUAL) ALPHA =',alpha
       alph = 0
       def = 1
    endif
    if (zb and ks(uldfile) ne 0 and ifbet)then begin
       if (in_idf(0) ne -1)then begin
          con = reform(config(*,in_idf(0)))
          beta = fltarr(4)
          for j = 0,3 do beta(j) = coeff(1,con(j),j)
       endif else begin
          print,'IDF ', idf,$
          ' OUT OF CALIBRATION RANGES - USING DEFAULT BETA!'
          beta = beta_default
       endelse 
       print,'USING BETA =',beta
    endif
    if (ks(bet) ne 0 and ks(uldfile) ne 0)then begin
       beta = bet
       print,'USING (MANUAL) BETA =',beta
       bet = 0
       def = 1
    endif
;**********************************************************************
; Do some other stuff:
;**********************************************************************
    if (ks(err) ne 0)then begin
       idf = -1 & typ = 'bail'
       spectra = lonarr(4,1,256)
       acc = '0'
    endif
    if (total(idfrange) le 0)then in = 1 else begin
       in = idf ge idfrnge(0) and idf le idfrnge(1) 
       if (idf gt idfrnge(1)) then acc = '0'
    endelse
    if (typ eq 'BRST')then begin
       burst = 1
       if(n_elements(spectra) gt 1)then not0 = 1 else not0 = 0 
    endif else begin
       burst = 0
       if (n_elements(spectra(0,*,0)) gt 1)then not0 = 1 else $
       not0 = 0
    endelse
    special = typ eq 'EVTs' or typ eq 'BRST'
    if (string(flag) eq 'done')then begin
       in = 0 
       acc = '0'
    endif
    if (special and not0)then begin
;**********************************************************************
; Event list idf:
;**********************************************************************
       nowait = burst
       if (count eq -1 and ks(mode) eq 0 and in)then wevt
       if (chc eq 'h' and in)then begin
          if (count eq -1 and ks(prms) eq 0)then begin
             prms = [1.,0.,63.,2] & prms_save = prms
             count = 0
          endif
          make_hist,typ,spectra
          mode = 'h'
          typsave = 'HSTs'
       endif
       if (chc eq 'p' and in)then begin
          if (count eq -1 and ks(prms) eq 0)then begin
             prms = [1.,1.,1.,1.] & prms_save = prms
             count = 0
          endif
          make_ph,typ,spectra,idf_hdr
          mode = 'p'
          typsave = 'PHSs'
       endif
       if (chc eq 'm' and in)then begin
          if (count eq -1 and ks(prms) eq 0)then begin
             if (ks(tres) eq 0)then tres = 16.
             if (tres gt 16.)then tres = 16.
             print,'USING TRES = ',tres,' S'
             print,'USING PHA EDGES: ',edgs 
             prms = [[tres(0),1,0],edgs(*)]
             prms_save = prms
             count = 0
          endif
          mode = 'm'
          typ = 'MSCs'
;          make_ms,typ,spectra,idf_hdr,man=manual(i),ev=evts,id=idf,$
;                  li=livetime
          typsave = typ
       endif
       if (chc eq 'prs' and in)then begin
          prs = 1
          if (count eq -1 and ks(prms) eq 0)then begin
             prms = [1.,0.,0.,10.] & prms_save = prms
             count = 0
          endif
          typ = 'HSTs'
          mode = 'prs'
          typsave = typ
       endif
       if (chc eq 'done')then begin
          typ = 'EVTs'
          acc = '0'
          modesave = 0
       endif 
    endif  
    a = total(ulds_s) ne 0l
    b = total(ulds) ne total(ulds_s)
    if (typ eq 'HSTs' and idf ne idfold and in) then begin
;**********************************************************************
; Histogram Idf: must do phase-resolved stuff AFTER doing the 
; 1 IDF shift correction.
;**********************************************************************
       if (a and b)then begin
          in = where(livetime lt 0.)
          hist_stor,idf_hdr,idf,date,spectra,livetime,typ,idflost,$
                    no=nowait,xu=xulds_s,ul=ulds_s,id=idfarr_s,$
                     ar=arms_s,tr=trigs_s,ve=vetos_s
          if (ks(idf0) eq 0)then idf0 = idf
          del = dblarr(2)
          del(0) = double(long(16.*(idf-idf0)))       
          if (chc eq 'prs')then make_prs,del=del,man=manual(i)
          ulds_s = ulds
          xulds_s = xulds
          idfarr_s = idfarr
          arms_s = arms
          trigs_s = trigs
          vetos_s = vetos 
       endif else begin
          hist_stor,idf_hdr,idf,date,spectra,livetime,$
                    typ,idflost,no=nowait,xu=xulds,ul=ulds,id=idfarr,$
                     ar=arms,tr=trigs,ve=vetos
          if (ks(idf0) eq 0)then idf0 = idf
          del = dblarr(2)
          del(0) = double(long(16.*(idf-idf0)))
          if (chc eq 'prs')then make_prs,del=del,man=manual(i)
       endelse
;**********************************************************************
; Now do the histogram accumulation:
;**********************************************************************
       c = idf ge idfrnge(0) or total(idfrnge) le 1l
       d = idf le idfrnge(1) or total(idfrnge) le 1l
       v = where(idf eq skipidf)
       noskip = v(0) eq -1 
       if (noskip eq 0)then print,'SKIPPING IDF ',idf
       if (c and d and noskip)then begin
          hist,1,pr=prs,ia=iarr
          count = temporary(count) + 1
          idfold = idf
       endif 
    endif
    if (typ eq 'PHSs' and idf ne idfold and in) then begin
;**********************************************************************
; Pha Psa Idf:
;**********************************************************************
       if (a and b)then begin
          phapsa_stor,idf_hdr,idf,date,spectra,livetime,typ,idflost,$
                     no=nowait,xu=xulds_s,ul=ulds_s,id=idfarr_s,$
                      ar=arms_s,tr=trigs_s,ve=vetos_s
          if (ks(idf0) eq 0)then idf0 = idf
          ulds_s = ulds
          xulds_s = xulds
          idfarr_s = idfarr
          arms_s = arms
          trigs_s = trigs
          vetos_s = vetos 
       endif else begin
          phapsa_stor,idf_hdr,idf,date,spectra,livetime,typ,idflost,$
                     no=nowait,xu=xulds,ul=ulds,id=idfarr,ar=arms,$
                      tr=trigs,ve=vetos
          if (ks(idf0) eq 0)then idf0 = idf
       endelse
       c = idf ge idfrnge(0) or total(idfrnge) le 1l
       d = idf le idfrnge(1) or total(idfrnge) le 1l
       v = where(idf eq skipidf)
       noskip = v(0) eq -1 
       if (noskip eq 0)then print,'SKIPPING IDF ',idf
       if (c and d and noskip)then begin
          phapsa,1,ia=iarr
          count = temporary(count) + 1
          idfold = idf
       endif 
    endif
    if (typ eq 'MSCs' and idf ne idfold and in) then begin
;**********************************************************************
; Multiscalar Idf.
;**********************************************************************
       if (a and b)then begin
          msclr_stor,idf_hdr,idf,date,spectra,livetime,typ,idflost,$
                     no=nowait,xu=xulds_s,ul=ulds_s,id=idfarr_s,$
                      ev=evts,ar=arms_s,tr=trigs_s,ve=vetos_s,$
                       man=manual(i),mo=mode
          ulds_s = ulds
          xulds_s = xulds
          idfarr_s = idfarr
          arms_s = arms
          trigs_s = trigs
          vetos_s = vetos 
       endif else begin
          msclr_stor,idf_hdr,idf,date,spectra,livetime,typ,idflost,$
                     no=nowait,xu=xulds,ul=ulds,id=idfarr,ar=arms,$
                      tr=trigs,ve=vetos,man=manual(i),ev=evts,mo=mode
       endelse
       c = idf ge idfrnge(0) or total(idfrnge) le 1l
       d = idf le idfrnge(1) or total(idfrnge) le 1l
       v = where(idf eq skipidf)
       noskip = v(0) eq -1 
       if (noskip eq 0)then print,'SKIPPING IDF ',idf
       if (c and d and noskip)then begin
          msclr,1,ia=iarr
          count = temporary(count) + 1
          idfold = idf
       endif
    endif
;**********************************************************************
; If lost idf print two previous cluster positions
;**********************************************************************
    if (idflost ne -1)then begin
       print,'IDF',idflost,' LOST, PREVIOUS TWO CLUSTER '+ $
             'POSITIONS WERE : ',last2pos(0),', ',last2pos(1)
       last2pos(0) = '?'
    endif
;**********************************************************************
; Update last two cluster positions
;**********************************************************************
    last2pos = shift(last2pos,1)
    if (ks(err) eq 0)then last2pos(0) = idf_hdr.clstr_postn else $
    last2pos(0) = '?'
    if (typ eq 'ARCh' and idf ne idfold and in) then begin 
;**********************************************************************
; Start Archive histogram Idf:
;**********************************************************************
       if (ks(uldfile) ne 0)then begin
          gnu = float(reform(total(spectra,3)))
          if (a and b)then begin
             dead_corr,idf,idf_hdr,livetime,idfarr_s,xulds_s,ulds_s,$
                       arms_s,trigs_s,vetos_s,livetime_out,nu=gnu
             livetime = livetime_out
             ulds_s = ulds
             xulds_s = xulds
             idfarr_s = idfarr 
          endif else begin
             dead_corr,idf,idf_hdr,livetime,idfarr,xulds,ulds,$
                       arms,trigs,vetos,livetime_out,nu=gnu
             livetime = livetime_out
          endelse
       endif
       archist_stor,idf_hdr,idf,date,spectra,livetime,typ,noroll
       c = idf ge idfrnge(0) or total(idfrnge) le 1l
       d = idf le idfrnge(1) or total(idfrnge) le 1l
       v = where(idf eq skipidf)
       noskip = v(0) eq -1 
       if (noskip eq 0)then print,'SKIPPING IDF ',idf
       if (c and d and noskip)then begin
          archist,1,ia=iarr,sp=sp0,cp=cp
          cp_ndx = 2
          if(cp eq '+3.0' or cp eq '+1.5')then cp_ndx = 0
          if(cp eq '-3.0' or cp eq '-1.5')then cp_ndx = 1
;**********************************************************************
; Now process IDF - must do evil Dan MacDonald stuff:
;**********************************************************************
          if (total(sp0) ne -1) then begin
             sp0 = total(sp0,2)
             nd = n_elements(sp0(*,0))
             dlc_add = lonarr(nd,nc)
             for j1 = 0,nd-1 do begin
              for j2 = 0,nc-1 do begin
               e1 = edgs(j2) - 1 & e2 = edgs(j2+1) - 1
               dlc_add(j1,j2) = total(sp0(j1,e1:e2))
              endfor
             endfor
             if (n_elements(dlc) eq 0)then begin
                dlc = lonarr(4,nd,nc)
                dlc(cp_ndx,*,*) = dlc_add
             endif else begin
                sz = size(dlc)
                if (sz(0) eq 3)then z = 1 else $
                z = n_elements(dlc(0,0,0,*))
                dlc_new = lonarr(4,nd,nc,z+1)
                dlc_new(*,*,*,0:z-1) = dlc
                dlc_new(cp_ndx,*,*,z) = dlc_add
                dlc = dlc_new
             endelse
             dlc_out = dlc
             count = temporary(count) + 1
             idfold = idf & start = 0
          endif
       endif      
    endif
    if (typ eq 'ARCm' and idf ne idfold and in)  then begin
;**********************************************************************
; Archive multiscalar Idf
;**********************************************************************
       if (a and b)then begin
          am_stor,idf_hdr,idf,date,spectra,livetime,$
          typ,idflost,no=nowait,xu=xulds_s,ul=ulds_s,$
          id=idfarr_s,ar=arms_s,tr=trigs_s,ve=vetos_s
          ulds_s = ulds
          xulds_s = xulds
          idfarr_s = idfarr
          arms_s = arms
          trigs_s = trigs
          vetos_s = vetos 
       endif else begin
          am_stor,idf_hdr,idf,date,spectra,livetime,$
          typ,idflost,no=nowait,xu=xulds,ul=ulds,$
          id=idfarr,ar=arms,tr=trigs,ve=vetos
       endelse
       c = idf ge idfrnge(0) or total(idfrnge) le 1l
       d = idf le idfrnge(1) or total(idfrnge) le 1l
       v = where(idf eq skipidf)
       noskip = v(0) eq -1 
       if (noskip eq 0)then print,'SKIPPING IDF ',idf
       if (c and d and noskip)then begin
          am,1,ia=iarr
          count = temporary(count) + 1
          idfold = idf
       endif
;       am_stor,idf_hdr,idf,date,spectra,livetime,typ
;       am,1,ia=iarr
;       count = temporary(count) + 1
;       idfold = idf & start = 0
    endif
    if (typ eq 'CALh' and idf ne idfold and in) then begin
;**********************************************************************
; Callibration histogram Idf:
;**********************************************************************
       calhist_stor,idf_hdr,idf,date,spectra,livetime,typ
       calhist,1,ia=iarr
       count = temporary(count) + 1
       idfold = idf & start = 0
    endif
 endwhile
;**********************************************************************
; Reset alpha and beta, force a new parameter lookup (if not manual).
;**********************************************************************
 if (ks(def) eq 0)then begin
    alph = 0 & alpha = alph
    bet = 0 & beta = bet
 endif
;**********************************************************************
; Save the ULD stuff for when we change files:
;**********************************************************************
 if(ks(uldfile) ne 0)then begin
    ulds_s = ulds
    xulds_s = xulds
    idfarr_s = idfarr
    arms_s = arms
    vetos_s = vetos
    trigs_s = trigs
 endif
endfor
if (ks(typsave) ne 0)then typ = typsave
if (modesave and widgets)then begin
;**********************************************************************
; Option for start of widgets session
;**********************************************************************
   print,'START WIDGETS SESSION (y/n) ?'
   ans = ''
   read,ans
   if (ans eq 'y')then begin
      new = 0 & start = 0
      case typ of 
         'HSTs' : hist,pr=prs,ia=iarr
         'ARCh' : archist,ia=iarr
         'CALh' : calhist
         'MSCs' : msclr,ia=iarr
         'ARCm' : am,ia=iarr
         'PHSs' : phapsa,ia=iarr
         'EVTs' : wevt
      endcase
   endif
endif
;**********************************************************************
; Done accumulating, now go get accumulated quantities from
; the common blocks:
;**********************************************************************
if (typ ne 'EVTs')then begin
   case typ of
      'HSTs' : hev_get,a_counts,a_livetime,idfs,idfe,dt,idf_lvtme,$
                       clstr_pos
      'ARCh' : archev_get,a_counts,a_livetime,idfs,idfe,dt,idf_lvtme,$
                          clstr_pos
      'CALh' : chev_get,a_counts,a_livetime,idfs,idfe,dt,idf_lvtme,$
                        clstr_pos
      'MSCs' : mev_get,a_counts,a_livetime,idfs,idfe,pha_edgs,dt,$
                       idf_lvtme,clstr_pos,phz_arr,period,tedgs
      'ARCm' : amev_get,a_counts,a_livetime,idfs,idfe,pha_edgs,dt,$
                        idf_lvtme,clstr_pos,phz_arr,period
      'PHSs' : pev_get,a_counts,a_livetime,idfs,idfe,det_str,dt,$
                       idf_lvtme,clstr_pos
   endcase
   print,'IDFS',idfs,' TO',idfe,' ACCUMULATED'
   print,'CLUSTER POSITION INDEX :'
   print,'0............OFF SOURCE (+)'
   print,'1............OFF SOURCE (-)'
   print,'2............ON SOURCE'
   print,'3............ANY'
endif else begin
   print,'GET_ACCUM: NO DATA ACCUMULATED!'
   a_counts = -1
endelse
;**********************************************************************
; Flush variables from the common blocks, making it unecessary
; to exit IDL before using it again.
;**********************************************************************
base = 0 & idfold = 0 & beep = 0 & chc = 0
whist = 0 & wphapsa = 0 & wcalhist = 0 & wmsclr = 0 & warchist = 0 
wam = 0 & wfit = 0 & wold = 0 & idflost = -1
prms = 0 & prms_save = 0
case typ of 
   'HSTs' : flush_hist
   'ARCh' : flush_arch
   'CALh' : flush_calh
   'MSCs' : flush_mscl
   'ARCm' : flush_amsc
   'PHSs' : flush_phap
   'EVTs' : flush_evts
endcase
;**********************************************************************
; Thats all ffolks
;**********************************************************************
return
end
